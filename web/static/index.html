<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meiko â€¢ Emergency Scanner</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* OLED Professional Theme */
        :root {
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a; 
            --bg-tertiary: #111111;
            --bg-card: #161616;
            --bg-hover: #1a1a1a;
            
            --border-primary: #333333;
            --border-secondary: #222222;
            --border-accent: #444444;
            
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --text-muted: #666666;
            
            --accent-blue: #00d4ff;
            --accent-green: #00ff88;
            --accent-red: #ff4444;
            --accent-yellow: #ffcc00;
            --accent-orange: #ff8800;
            --accent-purple: #aa44ff;
            
            --police-color: #0099ff;
            --fire-color: #ff4444;
            --ems-color: #00cc44;
            --emergency-color: #ff8800;
            --public-works-color: #44cc44;
            --education-color: #9944ff;
            --events-color: #ffcc00;
            --airport-color: #00ccff;
            
            --font-mono: 'JetBrains Mono', monospace;
            --font-sans: 'Inter', sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-sans);
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
            line-height: 1.5;
        }

        /* Header */
        .header {
            background: linear-gradient(90deg, var(--bg-secondary) 0%, rgba(0, 212, 255, 0.05) 50%, var(--bg-secondary) 100%);
            border-bottom: 1px solid var(--border-primary);
            padding: 0 24px;
            height: 64px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mascot-image {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid var(--accent-blue);
            background: var(--bg-tertiary);
            padding: 2px;
            transition: all 0.2s ease;
        }

        .mascot-image:hover {
            border-color: var(--accent-green);
            transform: scale(1.05);
        }

        .logo-text {
            display: flex;
            flex-direction: column;
        }

        .logo {
            font-size: 20px;
            font-weight: 700;
            color: var(--accent-blue);
            font-family: var(--font-mono);
        }

        .logo-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            font-family: var(--font-mono);
        }

        .system-status {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 12px;
            font-family: var(--font-mono);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
        }

        .status-indicator.online {
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        .status-indicator.offline {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }

        .status-indicator.connecting {
            border-color: #ffa726;
            color: #ffa726;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .meiko-status {
            display: flex;
            flex-direction: column;
        }

        .status-text {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .status-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Navigation */
        .nav-tabs {
            display: flex;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
        }

        .nav-tab {
            padding: 16px 24px;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
            font-family: var(--font-sans);
            font-weight: 500;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-tab:hover {
            color: var(--text-primary);
            background: var(--bg-hover);
        }

        .nav-tab.active {
            color: var(--accent-blue);
            border-bottom-color: var(--accent-blue);
        }

        /* Main Content */
        .main-content {
            padding: 24px;
            max-width: 1600px;
            margin: 0 auto;
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-secondary);
            margin-bottom: 24px;
        }

        .card-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-secondary);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .card-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-content {
            padding: 20px;
        }

        /* Timeline */
        .timeline {
            position: relative;
        }

        .timeline-item {
            display: flex;
            padding: 16px 0;
            border-bottom: 1px solid var(--border-secondary);
            position: relative;
        }

        .timeline-item:last-child {
            border-bottom: none;
        }

        .timeline-time {
            width: 80px;
            flex-shrink: 0;
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-muted);
            padding-top: 2px;
        }

        .timeline-icon {
            width: 32px;
            height: 32px;
            flex-shrink: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 16px;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .timeline-content {
            flex: 1;
            min-width: 0;
        }

        .timeline-title {
            font-weight: 500;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .timeline-description {
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .timeline-tags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .timeline-tag {
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            font-size: 11px;
            font-family: var(--font-mono);
            color: var(--text-secondary);
        }

        .timeline-controls {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .btn-small {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: var(--font-mono);
        }

        .btn-small:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        /* Service Type Styling */
        .timeline-item[data-service="POLICE"] .timeline-icon {
            border-color: var(--police-color);
            color: var(--police-color);
        }

        .timeline-item[data-service="FIRE"] .timeline-icon {
            border-color: var(--fire-color);
            color: var(--fire-color);
        }

        .timeline-item[data-service="EMS"] .timeline-icon {
            border-color: var(--ems-color);
            color: var(--ems-color);
        }

        .timeline-item[data-service="EMERGENCY"] .timeline-icon {
            border-color: var(--emergency-color);
            color: var(--emergency-color);
        }

        .timeline-item[data-service="PUBLIC_WORKS"] .timeline-icon {
            border-color: var(--public-works-color);
            color: var(--public-works-color);
        }

        .timeline-item[data-service="EDUCATION"] .timeline-icon {
            border-color: var(--education-color);
            color: var(--education-color);
        }

        /* Data Tables */
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid var(--border-primary);
            font-weight: 500;
            font-size: 12px;
            color: var(--text-secondary);
            background: var(--bg-tertiary);
            font-family: var(--font-mono);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .data-table td {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-secondary);
            font-size: 13px;
            font-family: var(--font-mono);
        }

        .data-table tr:hover {
            background: var(--bg-hover);
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: var(--bg-card);
            border: 1px solid var(--border-secondary);
            padding: 16px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            font-family: var(--font-mono);
            color: var(--accent-blue);
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            align-items: center;
        }

        .btn {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: var(--font-sans);
            font-size: 13px;
            font-weight: 500;
        }

        .btn:hover {
            background: var(--bg-hover);
            border-color: var(--border-accent);
        }

        .btn-primary {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            background: var(--accent-blue);
            opacity: 0.9;
        }

        .date-picker {
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-primary);
            font-family: var(--font-mono);
            font-size: 12px;
        }

        /* Loading States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: var(--text-muted);
        }

        .loading::before {
            content: "";
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-primary);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        .empty-state i {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 0 16px;
            }

            .main-content {
                padding: 16px;
            }

            .timeline-time {
                width: 60px;
                font-size: 11px;
            }

            .timeline-icon {
                width: 24px;
                height: 24px;
                margin: 0 12px;
                font-size: 12px;
            }

            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 12px;
            }
        }

        /* Hidden by default */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-card);
            border: 1px solid var(--border-primary);
            max-width: 700px;
            width: 90%;
            max-height: 85%;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border-secondary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-secondary);
        }

        .modal-header h3 {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
            transition: color 0.2s ease;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-body {
            padding: 24px;
        }

        .audio-player {
            width: 100%;
            margin: 16px 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            padding: 12px;
            position: relative;
        }

        .audio-player audio {
            width: 100%;
            background: transparent;
        }

        .audio-player audio::-webkit-media-controls-panel {
            background-color: var(--bg-tertiary);
        }

        .audio-player audio::-webkit-media-controls-play-button,
        .audio-player audio::-webkit-media-controls-pause-button {
            background-color: var(--accent-blue);
        }

        .custom-audio-player {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            padding: 16px;
            margin: 16px 0;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .play-button {
            width: 40px;
            height: 40px;
            background: var(--accent-blue);
            border: none;
            border-radius: 50%;
            color: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .play-button:hover {
            background: var(--accent-green);
            transform: scale(1.05);
        }

        .play-button:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
        }

        .audio-progress {
            flex: 1;
            height: 6px;
            background: var(--border-secondary);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }

        .audio-progress-fill {
            height: 100%;
            background: var(--accent-blue);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s ease;
        }

        .audio-time {
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 60px;
        }

        .audio-volume {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .volume-slider {
            width: 60px;
            height: 4px;
            background: var(--border-secondary);
            border-radius: 2px;
            appearance: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
        }

        /* Enhanced Call Details */
        .call-details {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 8px 20px;
            font-family: var(--font-mono);
            font-size: 13px;
            margin-bottom: 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
            padding: 16px;
            border-radius: 4px;
        }

        .call-details dt {
            color: var(--text-secondary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 11px;
            align-self: start;
            padding: 2px 0;
        }

        .call-details dd {
            color: var(--text-primary);
            margin: 0;
            line-height: 1.4;
            word-break: break-word;
            overflow-wrap: break-word;
            padding: 2px 0;
        }

        .call-meta-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        .call-meta-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
            padding: 16px 12px;
            border-radius: 4px;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .call-meta-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            line-height: 1.2;
        }

        .call-meta-value {
            font-family: var(--font-mono);
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 500;
            line-height: 1.3;
            word-break: break-word;
            overflow-wrap: break-word;
        }

        .call-transcription-section {
            margin-top: 20px;
        }

        .transcription-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .transcription-content {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            padding: 16px;
            border-left: 4px solid var(--accent-blue);
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-primary);
        }

        /* Timeline Enhancements */
        .timeline-controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        /* Live Scanner Styles */
        .live-scanner-container {
            display: grid;
            grid-template-rows: auto 1fr auto;
            height: calc(100vh - 200px);
            gap: 16px;
        }

        .live-scanner-header {
            background: var(--bg-card);
            border: 1px solid var(--border-secondary);
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .scanner-status {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .scanner-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: var(--font-mono);
            font-size: 14px;
        }

        .scanner-indicator.live {
            color: var(--accent-red);
        }

        .scanner-indicator.standby {
            color: var(--text-secondary);
        }

        .pulse-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .scanner-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .volume-control input[type="range"] {
            width: 80px;
        }

        .live-player-container {
            background: var(--bg-card);
            border: 1px solid var(--border-secondary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .waveform-container {
            position: relative;
            height: 120px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-secondary);
            overflow: hidden;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .playback-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, rgba(0, 212, 255, 0.1) 0%, transparent 2%, transparent 98%, rgba(0, 212, 255, 0.1) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .waveform-container.playing .playback-overlay {
            opacity: 1;
        }

        .time-indicator {
            position: absolute;
            top: 8px;
            right: 12px;
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-secondary);
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 8px;
            border-radius: 2px;
        }

        .current-call-info {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-secondary);
            display: none;
        }

        .current-call-info.active {
            display: block;
            background: linear-gradient(90deg, var(--bg-secondary) 0%, rgba(0, 212, 255, 0.05) 100%);
        }

        .call-info-grid {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 16px;
            align-items: center;
        }

        .call-info-details {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .call-info-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .call-info-meta {
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-secondary);
        }

        .call-info-duration {
            font-family: var(--font-mono);
            font-size: 14px;
            color: var(--accent-blue);
            font-weight: 500;
        }

        .live-transcription {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .transcription-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-secondary);
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .transcription-title {
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .transcription-feed {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            font-size: 14px;
            line-height: 1.6;
        }

        .transcription-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
            position: relative;
            animation: slideIn 0.3s ease-out;
        }

        .transcription-item.new {
            border-color: var(--accent-blue);
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.3);
            animation: slideIn 0.3s ease-out, glow 2s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes glow {
            0% { box-shadow: 0 0 8px rgba(0, 212, 255, 0.3); }
            50% { box-shadow: 0 0 16px rgba(0, 212, 255, 0.6); }
            100% { box-shadow: 0 0 8px rgba(0, 212, 255, 0.3); }
        }

        .transcription-meta {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
            font-family: var(--font-mono);
        }

        .transcription-time {
            color: var(--text-secondary);
        }

        .transcription-talkgroup {
            color: var(--accent-blue);
            font-weight: 500;
        }

        .transcription-text {
            color: var(--text-primary);
            line-height: 1.5;
        }

        .empty-transcription {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        .empty-transcription i {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* Responsive adjustments for live scanner */
        @media (max-width: 768px) {
            .live-scanner-container {
                height: calc(100vh - 150px);
            }

            .scanner-status {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .call-info-grid {
                grid-template-columns: 1fr;
                gap: 12px;
                text-align: center;
            }

            .waveform-container {
                height: 80px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <div class="logo-container">
                <img src="/static/Meiko.png" alt="Meiko" class="mascot-image">
                <div class="logo-text">
                    <div class="logo">MEIKO</div>
                    <div class="logo-subtitle">Scanner Dashboard</div>
                </div>
            </div>
            <div class="system-status">
                <div class="status-indicator online" id="system-status">
                    <i class="fas fa-circle"></i>
                    <span>ONLINE</span>
                </div>
                <div class="status-indicator" id="sdr-status">
                    <i class="fas fa-radio"></i>
                    <span>SDR</span>
                </div>
                <div class="status-indicator" id="discord-status">
                    <i class="fab fa-discord"></i>
                    <span>DISCORD</span>
                </div>
            </div>
        </div>
        <div class="header-right">
            <div class="meiko-status">
                <div class="status-text" id="meiko-status-text">Ready for monitoring</div>
                <div class="status-subtitle" id="meiko-status-subtitle">Emergency services active</div>
            </div>
        </div>
    </header>

    <!-- Navigation -->
    <nav class="nav-tabs">
        <button class="nav-tab active" onclick="switchTab('timeline')">
            <i class="fas fa-stream"></i>
            Timeline
        </button>
        <button class="nav-tab" onclick="switchTab('live-scanner')">
            <i class="fas fa-broadcast-tower"></i>
            Live Scanner
        </button>
        <button class="nav-tab" onclick="switchTab('calls')">
            <i class="fas fa-phone"></i>
            Call Records
        </button>
        <button class="nav-tab" onclick="switchTab('analytics')">
            <i class="fas fa-chart-bar"></i>
            Analytics
        </button>
        <button class="nav-tab" onclick="switchTab('console')">
            <i class="fas fa-terminal"></i>
            Console
        </button>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Timeline Tab -->
        <div id="timeline" class="tab-content active">
            <div class="controls">
                <input type="date" class="date-picker" id="timeline-date" />
                <button class="btn" onclick="setTimelineDate('today')">TODAY</button>
                <button class="btn" onclick="setTimelineDate('yesterday')">YESTERDAY</button>
                <button class="btn" onclick="refreshTimeline()">
                    <i class="fas fa-refresh"></i>
                    REFRESH
                </button>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <i class="fas fa-stream"></i>
                        Activity Timeline
                    </div>
                </div>
                <div class="card-content">
                    <div id="timeline-container" class="timeline">
                        <div class="loading">Loading timeline events...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Live Scanner Tab -->
        <div id="live-scanner" class="tab-content">
            <div class="live-scanner-container">
                <!-- Scanner Header -->
                <div class="live-scanner-header">
                    <div class="scanner-status">
                        <div class="scanner-indicator" id="scanner-status">
                            <div class="pulse-dot"></div>
                            <span>STANDBY</span>
                        </div>
                        <div class="scanner-indicator">
                            <i class="fas fa-signal"></i>
                            <span id="active-frequency">Monitoring All Frequencies</span>
                        </div>
                    </div>
                    <div class="scanner-controls">
                        <div class="volume-control">
                            <i class="fas fa-volume-up"></i>
                            <input type="range" id="master-volume" min="0" max="100" value="75">
                            <span id="volume-display">75%</span>
                        </div>
                        <button class="btn" id="scanner-toggle" onclick="toggleLiveScanner()">
                            <i class="fas fa-play"></i>
                            START SCANNING
                        </button>
                        <button class="btn" onclick="testAudioPlayback()" style="margin-left: 8px;">
                            <i class="fas fa-volume-up"></i>
                            TEST AUDIO
                        </button>
                    </div>
                </div>

                <!-- Live Player -->
                <div class="live-player-container">
                    <!-- Waveform Display -->
                    <div class="waveform-container" id="waveform-container">
                        <canvas class="waveform-canvas" id="waveform-canvas"></canvas>
                        <div class="playback-overlay"></div>
                        <div class="time-indicator" id="current-time">00:00</div>
                    </div>

                    <!-- Current Call Info -->
                    <div class="current-call-info" id="current-call-info">
                        <div class="call-info-grid">
                            <div class="call-info-details">
                                <div class="call-info-title" id="call-info-title">-</div>
                                <div class="call-info-meta" id="call-info-meta">-</div>
                            </div>
                            <div class="call-info-duration" id="call-info-duration">-</div>
                        </div>
                    </div>

                    <!-- Live Transcription Feed -->
                    <div class="live-transcription">
                        <div class="transcription-header">
                            <div class="transcription-title">
                                <i class="fas fa-comment-dots"></i>
                                Live Transcription Feed
                            </div>
                            <button class="btn-small" onclick="clearTranscriptionFeed()">
                                <i class="fas fa-trash"></i>
                                CLEAR
                            </button>
                        </div>
                        <div class="transcription-feed" id="transcription-feed">
                            <div class="empty-transcription">
                                <i class="fas fa-microphone-slash"></i>
                                <p>Waiting for communications...</p>
                                <small>Live transcriptions will appear here as calls come in</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Call Records Tab -->
        <div id="calls" class="tab-content">
            <div class="controls">
                <button class="btn" onclick="refreshCalls()">
                    <i class="fas fa-refresh"></i>
                    REFRESH
                </button>
                <select class="date-picker" id="calls-filter">
                    <option value="">All Calls</option>
                    <option value="today">Today</option>
                    <option value="yesterday">Yesterday</option>
                    <option value="week">This Week</option>
                </select>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <i class="fas fa-phone"></i>
                        Call Records
                    </div>
                </div>
                <div class="card-content">
                    <div id="calls-loading" class="loading" style="display: none;">
                        Loading call records...
                    </div>
                    <table class="data-table" id="calls-table">
                        <thead>
                            <tr>
                                <th>TIMESTAMP</th>
                                <th>DEPARTMENT</th>
                                <th>TALKGROUP</th>
                                <th>DURATION</th>
                                <th>FREQUENCY</th>
                                <th>TRANSCRIPTION</th>
                            </tr>
                        </thead>
                        <tbody id="calls-tbody">
                            <!-- Call records will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Analytics Tab -->
        <div id="analytics" class="tab-content">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="total-calls-stat">-</div>
                    <div class="stat-label">Total Calls</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="calls-today-stat">-</div>
                    <div class="stat-label">Calls Today</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="active-talkgroups-stat">-</div>
                    <div class="stat-label">Active Talkgroups</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="system-uptime-stat">-</div>
                    <div class="stat-label">Uptime</div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <i class="fas fa-robot"></i>
                        AI Activity Summary
                    </div>
                    <button class="btn-small" onclick="refreshSummary()">
                        <i class="fas fa-refresh"></i>
                        REFRESH
                    </button>
                </div>
                <div class="card-content" id="summary-content">
                    <div class="loading">Generating AI summary...</div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <i class="fas fa-chart-pie"></i>
                        Department Activity
                    </div>
                </div>
                <div class="card-content">
                    <div id="department-stats">Loading department statistics...</div>
                </div>
            </div>
        </div>

        <!-- Console Tab -->
        <div id="console" class="tab-content">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="cpu-usage">-</div>
                    <div class="stat-label">CPU Usage</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="memory-usage">-</div>
                    <div class="stat-label">Memory Usage</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="disk-usage">-</div>
                    <div class="stat-label">Disk Usage</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="temperature">-</div>
                    <div class="stat-label">Temperature</div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <i class="fas fa-terminal"></i>
                        System Logs
                    </div>
                    <button class="btn-small" onclick="refreshLogs()">
                        <i class="fas fa-refresh"></i>
                        REFRESH
                    </button>
                </div>
                <div class="card-content">
                    <div id="logs-container" style="height: 400px; overflow-y: auto; font-family: var(--font-mono); font-size: 12px;">
                        <div class="loading">Loading system logs...</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Call Details Modal -->
    <div id="call-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><img src="/static/Meiko.png" alt="Meiko" style="width: 24px; height: 24px; margin-right: 8px; vertical-align: middle;">Call Details</h3>
                <button class="modal-close" onclick="closeCallModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="call-details" id="call-details-content">
                    <!-- Call details will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let ws = null;
        let currentTab = 'timeline';
        let currentDate = new Date().toISOString().split('T')[0];

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            connectWebSocket();
            startConnectivityMonitor(); // Start monitoring WebSocket connection
            loadSystemStats();
            loadTimeline();
            startMeikoPersonality();
            setInterval(updateSystemStats, 5000); // Update every 5 seconds
        });

        // Meiko personality system
        function startMeikoPersonality() {
            const statusTexts = [
                "Ready for monitoring",
                "Scanning frequencies",
                "Listening for activity", 
                "Standing by",
                "Monitoring channels",
                "Awaiting transmissions"
            ];

            const subtitleTexts = [
                "Emergency services active",
                "All systems operational", 
                "Scanner network online",
                "Communications clear",
                "Ready to assist",
                "Monitoring in progress"
            ];

            let statusIndex = 0;
            let subtitleIndex = 0;

            setInterval(() => {
                if (Math.random() > 0.7) { // 30% chance to update
                    statusIndex = (statusIndex + 1) % statusTexts.length;
                    document.getElementById('meiko-status-text').textContent = statusTexts[statusIndex];
                }
                
                if (Math.random() > 0.8) { // 20% chance to update
                    subtitleIndex = (subtitleIndex + 1) % subtitleTexts.length;
                    document.getElementById('meiko-status-subtitle').textContent = subtitleTexts[subtitleIndex];
                }
            }, 10000); // Check every 10 seconds
        }

        // WebSocket connection
        let wsReconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                console.log('WebSocket connected');
                updateSystemStatus('online');
                wsReconnectAttempts = 0; // Reset reconnect attempts on successful connection
                
                // Update Meiko status
                updateMeikoStatus("System connected", "Real-time monitoring active");
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };
            
            ws.onclose = function(event) {
                console.log('WebSocket disconnected', event.code, event.reason);
                updateSystemStatus('offline');
                
                // Update Meiko status
                updateMeikoStatus("Connection lost", "Attempting to reconnect...");
                
                // Attempt to reconnect with exponential backoff
                if (wsReconnectAttempts < maxReconnectAttempts) {
                    wsReconnectAttempts++;
                    const delay = Math.min(1000 * Math.pow(2, wsReconnectAttempts), 30000); // Max 30 second delay
                    console.log(`Attempting to reconnect in ${delay}ms (attempt ${wsReconnectAttempts}/${maxReconnectAttempts})`);
                    setTimeout(connectWebSocket, delay);
                } else {
                    console.log('Max reconnection attempts reached');
                    updateMeikoStatus("Connection failed", "Manual refresh required");
                }
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                updateSystemStatus('offline');
                
                // Update Meiko status  
                updateMeikoStatus("Connection error", "Network issues detected");
            };
        }
        
        // Periodic connectivity check
        function startConnectivityMonitor() {
            setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    // Connection is healthy
                    updateSystemStatus('online');
                } else if (ws && ws.readyState === WebSocket.CONNECTING) {
                    // Currently connecting
                    updateSystemStatus('connecting');
                } else {
                    // Connection is closed or failed
                    updateSystemStatus('offline');
                }
            }, 5000); // Check every 5 seconds
        }

        // Tab switching
        function switchTab(tabName) {
            // Update navigation
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');

            currentTab = tabName;

            // Load content for the selected tab
            switch(tabName) {
                case 'timeline':
                    loadTimeline();
                    break;
                case 'live-scanner':
                    if (!liveScanner.waveformCanvas) {
                        initLiveScanner();
                    }
                    // Auto-start scanner when tab is opened for testing
                    if (!liveScanner.isActive) {
                        console.log('Live Scanner tab opened - ready to start');
                        updateMeikoStatus("Live Scanner ready", "Click START SCANNING to begin");
                    }
                    break;
                case 'calls':
                    loadCalls();
                    break;
                case 'analytics':
                    loadAnalytics();
                    break;
                case 'console':
                    loadConsole();
                    break;
            }
        }

        // System status updates
        function updateSystemStatus(status) {
            const statusEl = document.getElementById('system-status');
            const circle = statusEl.querySelector('i');
            
            if (status === 'online') {
                statusEl.className = 'status-indicator online';
                circle.className = 'fas fa-circle';
            } else if (status === 'connecting') {
                statusEl.className = 'status-indicator connecting';
                circle.className = 'fas fa-spinner fa-spin';
            } else {
                statusEl.className = 'status-indicator offline';
                circle.className = 'fas fa-times';
            }
        }

        // Timeline functions
        let isLoadingTimeline = false;
        
        function loadTimeline(silent = false) {
            // Prevent multiple simultaneous loads
            if (isLoadingTimeline) {
                return;
            }
            
            isLoadingTimeline = true;
            const container = document.getElementById('timeline-container');
            
            if (!silent) {
                container.innerHTML = '<div class="loading"><img src="/static/Meiko.png" alt="Meiko" style="width: 32px; height: 32px; opacity: 0.7; margin-right: 12px;">Meiko is scanning for events...</div>';
            }

            fetch(`/api/timeline?date=${currentDate}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    displayTimeline(data.events);
                    console.log(`Timeline loaded: ${data.events?.length || 0} events`);
                })
                .catch(error => {
                    console.error('Timeline load error:', error);
                    container.innerHTML = `
                        <div class="empty-state">
                            <img src="/static/MeikoConfused.png" alt="Confused Meiko" style="width: 64px; height: 64px; opacity: 0.3; margin-bottom: 16px;">
                            <p>Meiko encountered an error!</p>
                            <small style="color: var(--text-muted);">Failed to load timeline events: ${error.message}</small>
                        </div>
                    `;
                })
                .finally(() => {
                    isLoadingTimeline = false;
                });
        }

        function displayTimeline(events) {
            const container = document.getElementById('timeline-container');
            
            if (!events || events.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <img src="/static/MeikoConfused.png" alt="Confused Meiko" style="width: 64px; height: 64px; opacity: 0.5; margin-bottom: 16px;">
                        <p>Meiko is waiting for activity...</p>
                        <small style="color: var(--text-muted);">No events found for this date</small>
                    </div>
                `;
                return;
            }

            // Check if this is an auto-refresh with new data
            const currentItemCount = container.querySelectorAll('.timeline-item').length;
            const newItemCount = events.length;
            
            // Store current audio state before refresh
            let wasPlaying = false;
            let currentCallId = null;
            let audioCurrentTime = 0;
            
            if (currentTimelineAudio && currentTimelineButton) {
                wasPlaying = !currentTimelineAudio.paused;
                audioCurrentTime = currentTimelineAudio.currentTime;
                
                // Extract call ID from the audio src
                const srcMatch = currentTimelineAudio.src.match(/\/api\/calls\/(\d+)\/audio/);
                if (srcMatch) {
                    currentCallId = parseInt(srcMatch[1]);
                }
            }
            
            container.innerHTML = events.map(event => createTimelineItem(event)).join('');
            
            // Restore audio state if it was playing
            if (wasPlaying && currentCallId) {
                setTimeout(() => {
                    const newButton = container.querySelector(`[onclick="playCallAudio(${currentCallId})"]`);
                    if (newButton && currentTimelineAudio) {
                        currentTimelineButton = newButton;
                        currentTimelineAudio.currentTime = audioCurrentTime;
                        if (currentTimelineAudio.paused) {
                            currentTimelineAudio.play();
                        }
                        newButton.innerHTML = '<i class="fas fa-pause"></i> PAUSE';
                    }
                }, 100);
            }
            
            // Flash the timeline briefly to indicate new data if items were added
            if (newItemCount > currentItemCount && currentItemCount > 0) {
                container.style.transition = 'background-color 0.3s ease';
                container.style.backgroundColor = 'rgba(66, 165, 245, 0.1)';
                setTimeout(() => {
                    container.style.backgroundColor = '';
                    setTimeout(() => {
                        container.style.transition = '';
                    }, 300);
                }, 300);
            }
        }

        function createTimelineItem(event) {
            const timestamp = new Date(event.timestamp);
            const timeString = timestamp.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: true
            });

            // Build tags
            let tagsHTML = '';
            if (event.data) {
                if (event.data.talkgroup) {
                    tagsHTML += `<span class="timeline-tag">${event.data.talkgroup}</span>`;
                }
                if (event.data.frequency) {
                    tagsHTML += `<span class="timeline-tag">${event.data.frequency}</span>`;
                }
                if (event.data.duration) {
                    tagsHTML += `<span class="timeline-tag">${event.data.duration}s</span>`;
                }
            }

            // Build controls for call events
            let controlsHTML = '';
            if (event.type === 'call' && event.data && event.data.call_id) {
                controlsHTML = `
                                         <div class="timeline-controls">
                         <button class="btn-small play-btn" onclick="playCallAudio(${event.data.call_id})">
                             <i class="fas fa-play"></i> PLAY
                         </button>
                         <button class="btn-small" onclick="showCallDetails(${event.data.call_id})">
                             <i class="fas fa-info-circle"></i> DETAILS
                         </button>
                     </div>
                `;
            }

            const serviceType = event.data && event.data.service_type ? event.data.service_type : 'OTHER';

            return `
                <div class="timeline-item" data-service="${serviceType}">
                    <div class="timeline-time">${timeString}</div>
                    <div class="timeline-icon">
                        <i class="fas fa-${event.icon}"></i>
                    </div>
                    <div class="timeline-content">
                        <div class="timeline-title">${event.title}</div>
                        <div class="timeline-description">${event.description}</div>
                        <div class="timeline-tags">${tagsHTML}</div>
                        ${controlsHTML}
                    </div>
                </div>
            `;
        }

        // Date controls
        function setTimelineDate(period) {
            const today = new Date();
            switch(period) {
                case 'today':
                    currentDate = today.toISOString().split('T')[0];
                    break;
                case 'yesterday':
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);
                    currentDate = yesterday.toISOString().split('T')[0];
                    break;
            }
            document.getElementById('timeline-date').value = currentDate;
            loadTimeline();
        }

        function refreshTimeline() {
            const dateInput = document.getElementById('timeline-date');
            if (dateInput.value) {
                currentDate = dateInput.value;
            }
            loadTimeline();
        }

        // Call records functions
        function loadCalls() {
            const tbody = document.getElementById('calls-tbody');
            tbody.innerHTML = '<tr><td colspan="6" class="loading"><img src="/static/Meiko.png" alt="Meiko" style="width: 24px; height: 24px; opacity: 0.7; vertical-align: middle; margin-right: 8px;">Meiko is scanning call records...</td></tr>';

            fetch('/api/calls?limit=50')
                .then(response => response.json())
                .then(data => {
                    displayCalls(data.calls);
                })
                .catch(error => {
                    tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--text-muted);"><img src="/static/MeikoConfused.png" alt="Confused Meiko" style="width: 32px; height: 32px; opacity: 0.3; vertical-align: middle; margin-right: 8px;">Meiko couldn\'t load call records</td></tr>';
                });
        }

        function displayCalls(calls) {
            const tbody = document.getElementById('calls-tbody');
            
            if (!calls || calls.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--text-muted);"><img src="/static/MeikoConfused.png" alt="Confused Meiko" style="width: 32px; height: 32px; opacity: 0.5; vertical-align: middle; margin-right: 8px;">Meiko hasn\'t detected any calls yet</td></tr>';
                return;
            }

            tbody.innerHTML = calls.map(call => {
                const timestamp = new Date(call.timestamp);
                const duration = call.duration + 's';
                const transcription = call.transcription ? 
                    (call.transcription.length > 50 ? call.transcription.substring(0, 50) + '...' : call.transcription) :
                    'No transcription';

                // Format timestamp consistently with 12-hour format
                const formattedTime = timestamp.toLocaleString('en-US', {
                    weekday: 'short',
                    month: 'short', 
                    day: 'numeric',
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: true
                });

                return `
                    <tr onclick="showCallDetails(${call.id})" style="cursor: pointer;">
                        <td>${formattedTime}</td>
                        <td>${call.talkgroup_group || 'Unknown'}</td>
                        <td>${call.talkgroup_alias || call.talkgroup_id || 'Unknown'}</td>
                        <td>${duration}</td>
                        <td>${call.frequency || 'N/A'}</td>
                        <td>${transcription}</td>
                    </tr>
                `;
            }).join('');
        }

        // Analytics functions
        function loadAnalytics() {
            updateStatCards();
            loadSummary();
            loadDepartmentStats();
        }

        function updateStatCards() {
            fetch('/api/stats')
                .then(response => response.json())
                .then(stats => {
                    document.getElementById('total-calls-stat').textContent = stats.total_calls || '0';
                    document.getElementById('calls-today-stat').textContent = stats.calls_today || '0';
                    document.getElementById('active-talkgroups-stat').textContent = Object.keys(stats.talkgroups || {}).length;
                    
                    // Format uptime (convert from nanoseconds to seconds)
                    const uptimeNanos = stats.uptime || 0;
                    const uptimeSeconds = Math.floor(uptimeNanos / 1000000000);
                    const hours = Math.floor(uptimeSeconds / 3600);
                    const minutes = Math.floor((uptimeSeconds % 3600) / 60);
                    document.getElementById('system-uptime-stat').textContent = `${hours}h ${minutes}m`;
                })
                .catch(error => {
                    console.error('Failed to load stats:', error);
                });
        }

        function loadSummary() {
            const container = document.getElementById('summary-content');
            container.innerHTML = '<div class="loading"><img src="/static/Meiko.png" alt="Meiko" style="width: 32px; height: 32px; opacity: 0.7; margin-right: 12px;">Meiko is analyzing communications...</div>';

            fetch('/api/calls/summary/today')
                .then(response => response.json())
                .then(data => {
                    displaySummary(data);
                })
                .catch(error => {
                    container.innerHTML = `
                        <div class="empty-state">
                                                            <img src="/static/MeikoConfused.png" alt="Confused Meiko" style="width: 64px; height: 64px; opacity: 0.3; margin-bottom: 16px;">
                                <p>Meiko couldn't generate a summary</p>
                            <small style="color: var(--text-muted);">Analysis failed</small>
                        </div>
                    `;
                });
        }

        function displaySummary(data) {
            const container = document.getElementById('summary-content');
            
            if (data.summary) {
                const generatedAt = new Date(data.generated_at).toLocaleString('en-US', {
                    month: 'short', 
                    day: 'numeric',
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: true
                });
                container.innerHTML = `
                    <div style="margin-bottom: 12px; font-size: 12px; color: var(--text-muted); font-family: var(--font-mono);">
                        Generated: ${generatedAt} | Calls: ${data.call_count} | Range: ${data.time_range}
                    </div>
                    <div style="line-height: 1.6;">
                        ${data.summary.replace(/\n/g, '<br>')}
                    </div>
                `;
            } else {
                container.innerHTML = `
                    <div class="empty-state">
                        <img src="/static/MeikoConfused.png" alt="Confused Meiko" style="width: 64px; height: 64px; opacity: 0.5; margin-bottom: 16px;">
                        <p>Meiko has nothing to summarize yet</p>
                        <small style="color: var(--text-muted);">No activity to analyze</small>
                    </div>
                `;
            }
        }

        function loadDepartmentStats() {
            const container = document.getElementById('department-stats');
            
            fetch('/api/stats')
                .then(response => response.json())
                .then(stats => {
                    if (stats.talkgroups && Object.keys(stats.talkgroups).length > 0) {
                        const talkgroups = Object.entries(stats.talkgroups)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 10);

                        container.innerHTML = talkgroups.map(([name, count]) => `
                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border-secondary);">
                                <span>${name}</span>
                                <span style="font-family: var(--font-mono); color: var(--accent-blue);">${count}</span>
                            </div>
                        `).join('');
                    } else {
                        container.innerHTML = '<div class="empty-state"><img src="/static/MeikoConfused.png" alt="Confused Meiko" style="width: 48px; height: 48px; opacity: 0.5; margin-bottom: 12px;"><p>Meiko found no department data</p></div>';
                    }
                })
                .catch(error => {
                    container.innerHTML = '<div class="empty-state"><img src="/static/MeikoConfused.png" alt="Confused Meiko" style="width: 48px; height: 48px; opacity: 0.3; margin-bottom: 12px;"><p>Meiko couldn\'t load department stats</p></div>';
                });
        }

        // Console functions
        function loadConsole() {
            loadSystemStats();
            loadLogs();
        }

        function loadSystemStats() {
            fetch('/api/stats')
                .then(response => response.json())
                .then(stats => {
                    document.getElementById('cpu-usage').textContent = (stats.cpu || 0).toFixed(1) + '%';
                    document.getElementById('memory-usage').textContent = (stats.memory || 0).toFixed(1) + '%';
                    document.getElementById('disk-usage').textContent = (stats.disk || 0).toFixed(1) + '%';
                    document.getElementById('temperature').textContent = (stats.temperature || 0).toFixed(1) + 'Â°C';
                })
                .catch(error => {
                    console.error('Failed to load system stats:', error);
                });
        }

        function updateSystemStats() {
            if (currentTab === 'console' || currentTab === 'analytics') {
                loadSystemStats();
            }
        }

        function loadLogs() {
            const container = document.getElementById('logs-container');
            container.innerHTML = '<div class="loading"><img src="/static/Meiko.png" alt="Meiko" style="width: 32px; height: 32px; opacity: 0.7; margin-right: 12px;">Meiko is fetching system logs...</div>';

            fetch('/api/logs')
                .then(response => response.json())
                .then(data => {
                    if (data.logs && data.logs.length > 0) {
                        container.innerHTML = data.logs.map(log => {
                            const timestamp = new Date(log.timestamp).toLocaleTimeString('en-US', {
                                hour: '2-digit',
                                minute: '2-digit',
                                second: '2-digit',
                                hour12: true
                            });
                            const levelColor = getLevelColor(log.level);
                            // Clean message of any existing level indicators to prevent duplication
                            const cleanMessage = cleanLogMessage(log.message, log.level);
                            return `
                                <div style="margin-bottom: 8px; font-family: var(--font-mono); font-size: 12px;">
                                    <span style="color: var(--text-muted);">[${timestamp}]</span>
                                    <span style="color: ${levelColor}; font-weight: 500;">[${log.level}]</span>
                                    <span style="color: var(--text-secondary);">[${log.component}]</span>
                                    <span style="color: var(--text-primary);">${cleanMessage}</span>
                                </div>
                            `;
                        }).join('');
                        container.scrollTop = container.scrollHeight;
                    } else {
                        container.innerHTML = '<div class="empty-state"><img src="/static/MeikoConfused.png" alt="Confused Meiko" style="width: 48px; height: 48px; opacity: 0.5; margin-bottom: 12px;"><p>Meiko found no logs to display</p></div>';
                    }
                })
                .catch(error => {
                    container.innerHTML = '<div class="empty-state"><img src="/static/MeikoConfused.png" alt="Confused Meiko" style="width: 48px; height: 48px; opacity: 0.3; margin-bottom: 12px;"><p>Meiko couldn\'t access system logs</p></div>';
                });
        }

        // Utility functions
        function refreshCalls() {
            loadCalls();
        }

        function refreshSummary() {
            loadSummary();
        }

        function refreshLogs() {
            loadLogs();
        }

        // Call details modal
        function showCallDetails(callId) {
            fetch(`/api/calls/${callId}`)
                .then(response => response.json())
                .then(call => {
                    displayCallDetails(call);
                    document.getElementById('call-modal').style.display = 'block';
                })
                .catch(error => {
                    console.error('Failed to load call details:', error);
                    const container = document.getElementById('call-details-content');
                    container.innerHTML = `
                        <div class="empty-state">
                            <img src="/static/MeikoConfused.png" alt="Confused Meiko" style="width: 64px; height: 64px; opacity: 0.3; margin-bottom: 16px;">
                            <p>Meiko couldn't load call details</p>
                            <small style="color: var(--text-muted);">Failed to fetch call information</small>
                        </div>
                    `;
                    document.getElementById('call-modal').style.display = 'block';
                });
        }

        function displayCallDetails(call) {
            const container = document.getElementById('call-details-content');
            const timestamp = new Date(call.timestamp);
            const formattedTime = timestamp.toLocaleString('en-US', {
                weekday: 'long',
                year: 'numeric', 
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            });
            
            const duration = formatDuration(call.duration);
            
            container.innerHTML = `
                <div class="call-meta-grid">
                    <div class="call-meta-item">
                        <div class="call-meta-label">Call ID</div>
                        <div class="call-meta-value">#${call.id}</div>
                    </div>
                    <div class="call-meta-item">
                        <div class="call-meta-label">Duration</div>
                        <div class="call-meta-value">${duration}</div>
                    </div>
                    <div class="call-meta-item">
                        <div class="call-meta-label">Frequency</div>
                        <div class="call-meta-value">${call.frequency || 'Unknown'}</div>
                    </div>
                    <div class="call-meta-item">
                        <div class="call-meta-label">System</div>
                        <div class="call-meta-value">${call.talkgroup_group || 'Unknown'}</div>
                    </div>
                </div>

                <div class="call-details">
                    <dt>Timestamp</dt>
                    <dd>${formattedTime}</dd>
                    <dt>Talkgroup</dt>
                    <dd>${call.talkgroup_alias || call.talkgroup_id}</dd>
                    <dt>Filename</dt>
                    <dd>${call.filename}</dd>
                </div>

                <div class="custom-audio-player">
                    <div class="audio-controls">
                        <button class="play-button" id="play-btn-${call.id}">
                            <i class="fas fa-play"></i>
                        </button>
                        <div class="audio-progress" id="progress-${call.id}">
                            <div class="audio-progress-fill" id="progress-fill-${call.id}"></div>
                        </div>
                        <div class="audio-time" id="time-${call.id}">0:00 / 0:00</div>
                        <div class="audio-volume">
                            <i class="fas fa-volume-up"></i>
                            <input type="range" class="volume-slider" id="volume-${call.id}" min="0" max="100" value="100">
                        </div>
                    </div>
                    <audio id="audio-${call.id}" preload="metadata">
                        <source src="/api/calls/${call.id}/audio" type="audio/mpeg">
                    </audio>
                </div>

                ${call.transcription ? `
                    <div class="call-transcription-section">
                        <div class="transcription-header">
                            <i class="fas fa-quote-left"></i>
                            Transcription
                        </div>
                        <div class="transcription-content">
                            ${call.transcription}
                        </div>
                    </div>
                ` : ''}
            `;

            // Initialize custom audio player
            initCustomAudioPlayer(call.id);
        }

        // Custom audio player functionality
        function initCustomAudioPlayer(callId) {
            const audio = document.getElementById(`audio-${callId}`);
            const playBtn = document.getElementById(`play-btn-${callId}`);
            const progress = document.getElementById(`progress-${callId}`);
            const progressFill = document.getElementById(`progress-fill-${callId}`);
            const timeDisplay = document.getElementById(`time-${callId}`);
            const volumeSlider = document.getElementById(`volume-${callId}`);

            let isPlaying = false;

            // Play/pause functionality
            playBtn.addEventListener('click', () => {
                if (isPlaying) {
                    audio.pause();
                } else {
                    audio.play();
                }
            });

            // Update play button state
            audio.addEventListener('play', () => {
                isPlaying = true;
                playBtn.innerHTML = '<i class="fas fa-pause"></i>';
            });

            audio.addEventListener('pause', () => {
                isPlaying = false;
                playBtn.innerHTML = '<i class="fas fa-play"></i>';
            });

            // Update progress and time
            audio.addEventListener('timeupdate', () => {
                if (audio.duration) {
                    const progress = (audio.currentTime / audio.duration) * 100;
                    progressFill.style.width = progress + '%';
                    
                    const currentTime = formatTime(audio.currentTime);
                    const totalTime = formatTime(audio.duration);
                    timeDisplay.textContent = `${currentTime} / ${totalTime}`;
                }
            });

            // Progress bar click
            progress.addEventListener('click', (e) => {
                if (audio.duration) {
                    const rect = progress.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const clickProgress = x / rect.width;
                    audio.currentTime = clickProgress * audio.duration;
                }
            });

            // Volume control
            volumeSlider.addEventListener('input', (e) => {
                audio.volume = e.target.value / 100;
            });

            // Load metadata
            audio.addEventListener('loadedmetadata', () => {
                const totalTime = formatTime(audio.duration);
                timeDisplay.textContent = `0:00 / ${totalTime}`;
            });
        }

        // Helper function to format time
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Helper function to format duration
        function formatDuration(seconds) {
            if (seconds < 60) {
                return `${seconds}s`;
            }
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}m ${secs}s`;
        }

        // Helper function to get color for log level
        function getLevelColor(level) {
            switch (level.toUpperCase()) {
                case 'ERROR': return '#ff6b6b';
                case 'WARN': case 'WARNING': return '#ffa726';
                case 'INFO': return '#42a5f5';
                case 'DEBUG': return '#66bb6a';
                case 'SUCCESS': return '#4caf50';
                default: return 'var(--text-secondary)';
            }
        }

        // Helper function to clean log messages of duplicate level indicators
        function cleanLogMessage(message, logLevel) {
            if (!message) return message;
            
            let cleaned = message;
            
            // Remove level indicators that match the current log level at the start of message
            const levelPattern = new RegExp(`^\\s*\\[${logLevel}\\]\\s*`, 'i');
            cleaned = cleaned.replace(levelPattern, '');
            
            // Remove any duplicate level brackets like [[INFO]] at start
            const doubleLevelPattern = new RegExp(`^\\s*\\[\\[${logLevel}\\]\\]\\s*`, 'i');
            cleaned = cleaned.replace(doubleLevelPattern, '');
            
            // Remove generic level patterns at start of message (any level)
            const genericLevelPattern = /^\s*\[(INFO|WARN|ERROR|DEBUG|SUCCESS)\]\s*/i;
            cleaned = cleaned.replace(genericLevelPattern, '');
            
            // Remove double brackets patterns like [[LEVEL]]
            const doubleGenericPattern = /^\s*\[\[(INFO|WARN|ERROR|DEBUG|SUCCESS)\]\]\s*/i;
            cleaned = cleaned.replace(doubleGenericPattern, '');
            
            // Remove multiple consecutive level indicators
            const multipleLevelPattern = /(\[(INFO|WARN|ERROR|DEBUG|SUCCESS)\]\s*){2,}/gi;
            cleaned = cleaned.replace(multipleLevelPattern, '');
            
            return cleaned.trim();
        }

        function closeCallModal() {
            document.getElementById('call-modal').style.display = 'none';
        }

        // Global audio player for timeline
        let currentTimelineAudio = null;
        let currentTimelineButton = null;

        function playCallAudio(callId) {
            const button = event.target.closest('.play-btn');
            
            // Stop any currently playing audio first
            if (currentTimelineAudio && !currentTimelineAudio.paused) {
                currentTimelineAudio.pause();
                currentTimelineAudio.currentTime = 0;
                
                // Reset the old button if it exists and is different from current
                if (currentTimelineButton && currentTimelineButton !== button) {
                    currentTimelineButton.innerHTML = '<i class="fas fa-play"></i> PLAY';
                }
            }
            
            // If clicking the same audio that was already loaded
            if (currentTimelineAudio && currentTimelineAudio.src.includes(`/api/calls/${callId}/audio`) && currentTimelineButton === button) {
                if (currentTimelineAudio.paused) {
                    // Resume playback
                    currentTimelineAudio.play().then(() => {
                        button.innerHTML = '<i class="fas fa-pause"></i> PAUSE';
                    }).catch(error => {
                        console.error('Failed to resume audio:', error);
                        button.innerHTML = '<i class="fas fa-play"></i> PLAY';
                    });
                } else {
                    // Pause playback
                    currentTimelineAudio.pause();
                    button.innerHTML = '<i class="fas fa-play"></i> PLAY';
                }
                return;
            }
            
            // Create new audio instance for different call
            if (currentTimelineAudio) {
                currentTimelineAudio.pause();
                currentTimelineAudio = null;
            }
            
            currentTimelineAudio = new Audio(`/api/calls/${callId}/audio`);
            currentTimelineButton = button;
            
            // Set up event listeners
            currentTimelineAudio.addEventListener('ended', () => {
                if (currentTimelineButton) {
                    currentTimelineButton.innerHTML = '<i class="fas fa-play"></i> PLAY';
                }
            });
            
            currentTimelineAudio.addEventListener('pause', () => {
                if (currentTimelineButton) {
                    currentTimelineButton.innerHTML = '<i class="fas fa-play"></i> PLAY';
                }
            });
            
            currentTimelineAudio.addEventListener('play', () => {
                if (currentTimelineButton) {
                    currentTimelineButton.innerHTML = '<i class="fas fa-pause"></i> PAUSE';
                }
            });
            
            currentTimelineAudio.addEventListener('error', () => {
                console.error('Audio failed to load');
                if (currentTimelineButton) {
                    currentTimelineButton.innerHTML = '<i class="fas fa-play"></i> PLAY';
                }
            });
            
            // Start playback
            currentTimelineAudio.play().then(() => {
                button.innerHTML = '<i class="fas fa-pause"></i> PAUSE';
            }).catch(error => {
                console.error('Failed to play audio:', error);
                button.innerHTML = '<i class="fas fa-play"></i> PLAY';
            });
        }

        // WebSocket message handling
        function handleWebSocketMessage(data) {
            switch(data.type) {
                case 'stats_update':
                    if (currentTab === 'console' || currentTab === 'analytics') {
                        updateSystemStats();
                    }
                    break;
                case 'new_call':
                    // Meiko reacts to new calls
                    updateMeikoStatus("New transmission detected!", "Processing call data");
                    setTimeout(() => {
                        document.getElementById('meiko-status-text').textContent = "Ready for monitoring";
                        document.getElementById('meiko-status-subtitle').textContent = "Emergency services active";
                    }, 5000);

                    // Always refresh timeline if it's the current tab
                    if (currentTab === 'timeline') {
                        // Add a small delay to ensure the backend has processed the call
                        setTimeout(() => {
                            loadTimeline(true); // Silent refresh to avoid loading indicators
                        }, 500);
                    }
                    
                    // Always refresh calls if it's the current tab
                    if (currentTab === 'calls') {
                        setTimeout(() => {
                            loadCalls();
                        }, 500);
                    }
                    
                    // Update analytics if it's the current tab
                    if (currentTab === 'analytics') {
                        setTimeout(() => {
                            updateStatCards();
                        }, 1000);
                    }
                    
                    // Handle live scanner for new calls
                    handleWebSocketMessageForLiveScanner(data);
                    
                    console.log('New call received:', data.data);
                    break;
                case 'live_scanner_event':
                    // Handle live scanner specific events
                    handleWebSocketMessageForLiveScanner(data);
                    break;
                default:
                    console.log('Unknown message type:', data.type);
            }
        }

        // Update Meiko's status messages
        function updateMeikoStatus(statusText, subtitleText) {
            document.getElementById('meiko-status-text').textContent = statusText;
            document.getElementById('meiko-status-subtitle').textContent = subtitleText;
        }

        // ===== LIVE SCANNER FUNCTIONALITY =====
        
        // Live Scanner state
        let liveScanner = {
            isActive: false,
            currentAudio: null,
            waveformCanvas: null,
            waveformContext: null,
            animationId: null,
            transcriptionItems: [],
            lastCallId: null,
            volume: 0.75
        };

        // Initialize Live Scanner
        function initLiveScanner() {
            liveScanner.waveformCanvas = document.getElementById('waveform-canvas');
            liveScanner.waveformContext = liveScanner.waveformCanvas.getContext('2d');
            
            // Set up canvas sizing
            resizeWaveformCanvas();
            window.addEventListener('resize', resizeWaveformCanvas);
            
            // Set up volume control
            const volumeSlider = document.getElementById('master-volume');
            const volumeDisplay = document.getElementById('volume-display');
            
            volumeSlider.addEventListener('input', (e) => {
                liveScanner.volume = e.target.value / 100;
                volumeDisplay.textContent = e.target.value + '%';
                
                if (liveScanner.currentAudio) {
                    liveScanner.currentAudio.volume = liveScanner.volume;
                }
            });
            
            // Initialize waveform
            drawStandbyWaveform();
        }

        function resizeWaveformCanvas() {
            const container = document.getElementById('waveform-container');
            const canvas = liveScanner.waveformCanvas;
            
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            if (!liveScanner.isActive) {
                drawStandbyWaveform();
            }
        }

        function drawStandbyWaveform() {
            const ctx = liveScanner.waveformContext;
            const canvas = liveScanner.waveformCanvas;
            
            ctx.fillStyle = 'var(--bg-tertiary)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw static waveform
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            const centerY = canvas.height / 2;
            const segments = 200;
            
            for (let i = 0; i < segments; i++) {
                const x = (i / segments) * canvas.width;
                const amplitude = Math.sin(i * 0.1) * 10 + Math.sin(i * 0.05) * 5;
                const y = centerY + amplitude;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
        }

        function drawLiveWaveform(audioData) {
            const ctx = liveScanner.waveformContext;
            const canvas = liveScanner.waveformCanvas;
            
            // Clear canvas
            ctx.fillStyle = '#111111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!audioData) return;
            
            // Draw waveform
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const centerY = canvas.height / 2;
            const barWidth = canvas.width / audioData.length;
            
            for (let i = 0; i < audioData.length; i++) {
                const amplitude = audioData[i] * centerY;
                const x = i * barWidth;
                
                ctx.moveTo(x, centerY - amplitude);
                ctx.lineTo(x, centerY + amplitude);
            }
            
            ctx.stroke();
            
            // Add time indicator
            updateTimeIndicator();
        }

        function drawRealWaveform(waveformData) {
            const ctx = liveScanner.waveformContext;
            const canvas = liveScanner.waveformCanvas;
            
            // Clear canvas with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a0a0a');
            gradient.addColorStop(1, '#111111');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!waveformData || waveformData.length === 0) return;
            
            // Draw waveform bars
            const barWidth = canvas.width / waveformData.length;
            const centerY = canvas.height / 2;
            
            // Create gradient for waveform
            const waveGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            waveGradient.addColorStop(0, '#00d4ff');
            waveGradient.addColorStop(0.5, '#00ff88');
            waveGradient.addColorStop(1, '#00d4ff');
            
            ctx.fillStyle = waveGradient;
            
            for (let i = 0; i < waveformData.length; i++) {
                const amplitude = Math.abs(waveformData[i]) * centerY * 0.8;
                const x = i * barWidth;
                
                // Draw vertical bar
                ctx.fillRect(x, centerY - amplitude, barWidth - 1, amplitude * 2);
            }
            
            // Add reflection effect
            ctx.globalAlpha = 0.3;
            ctx.scale(1, -1);
            ctx.translate(0, -canvas.height);
            ctx.fillStyle = waveGradient;
            
            for (let i = 0; i < waveformData.length; i++) {
                const amplitude = Math.abs(waveformData[i]) * centerY * 0.4;
                const x = i * barWidth;
                
                ctx.fillRect(x, centerY - amplitude, barWidth - 1, amplitude);
            }
            
            // Reset transformations
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.globalAlpha = 1;
            
            // Add time indicator
            updateTimeIndicator();
        }

        function updateTimeIndicator() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', { 
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            document.getElementById('current-time').textContent = timeString;
        }

        function toggleLiveScanner() {
            if (liveScanner.isActive) {
                stopLiveScanner();
            } else {
                startLiveScanner();
            }
        }

        function startLiveScanner() {
            liveScanner.isActive = true;
            
            // Update UI
            const button = document.getElementById('scanner-toggle');
            const status = document.getElementById('scanner-status');
            
            button.innerHTML = '<i class="fas fa-stop"></i> STOP SCANNING';
            button.classList.add('btn-primary');
            
            status.className = 'scanner-indicator live';
            status.querySelector('span').textContent = 'LIVE';
            
            // Start waveform animation
            animateWaveform();
            
            // Start scanning simulation
            startLiveScannerMonitoring();
            
            // Update Meiko status
            updateMeikoStatus("Live scanner activated", "Monitoring all frequencies");
            
            console.log('Live scanner started - isActive:', liveScanner.isActive);
            
            // Show status in UI
            document.getElementById('active-frequency').textContent = 'Live Scanner Active - Waiting for calls';
        }

        function stopLiveScanner() {
            liveScanner.isActive = false;
            
            // Stop any playing audio
            if (liveScanner.currentAudio) {
                liveScanner.currentAudio.pause();
                liveScanner.currentAudio = null;
            }
            
            // Stop animation
            if (liveScanner.animationId) {
                cancelAnimationFrame(liveScanner.animationId);
                liveScanner.animationId = null;
            }
            
            // Update UI
            const button = document.getElementById('scanner-toggle');
            const status = document.getElementById('scanner-status');
            const waveformContainer = document.getElementById('waveform-container');
            const currentCallInfo = document.getElementById('current-call-info');
            
            button.innerHTML = '<i class="fas fa-play"></i> START SCANNING';
            button.classList.remove('btn-primary');
            
            status.className = 'scanner-indicator standby';
            status.querySelector('span').textContent = 'STANDBY';
            
            waveformContainer.classList.remove('playing');
            currentCallInfo.classList.remove('active');
            
            // Reset to standby waveform
            drawStandbyWaveform();
            
            // Update Meiko status
            updateMeikoStatus("Scanner stopped", "Standing by");
            
            console.log('Live scanner stopped');
        }

        function animateWaveform() {
            if (!liveScanner.isActive) return;
            
            // Generate fake waveform data for demonstration
            const dataPoints = 100;
            const audioData = new Array(dataPoints);
            
            for (let i = 0; i < dataPoints; i++) {
                // Create more realistic looking audio data
                const baseWave = Math.sin(Date.now() * 0.001 + i * 0.1) * 0.3;
                const noise = (Math.random() - 0.5) * 0.1;
                audioData[i] = baseWave + noise;
            }
            
            drawLiveWaveform(audioData);
            
            liveScanner.animationId = requestAnimationFrame(animateWaveform);
        }

        function startLiveScannerMonitoring() {
            if (!liveScanner.isActive) return;
            
            // Simulate scanning activity
            setInterval(() => {
                if (!liveScanner.isActive) return;
                
                // Randomly update frequency display to simulate scanning
                const frequencies = ['453.100', '453.200', '453.300', '460.100', '460.200'];
                const services = ['Police Dispatch', 'Fire Department', 'EMS Services', 'Public Works', 'Airport Operations'];
                
                if (Math.random() > 0.8) { // 20% chance to update
                    const randomFreq = frequencies[Math.floor(Math.random() * frequencies.length)];
                    const randomService = services[Math.floor(Math.random() * services.length)];
                    
                    document.getElementById('active-frequency').textContent = 
                        `Scanning ${randomFreq} â€¢ ${randomService}`;
                        
                    // Briefly flash the frequency display
                    const freqElement = document.getElementById('active-frequency');
                    freqElement.style.color = 'var(--accent-blue)';
                    setTimeout(() => {
                        freqElement.style.color = '';
                    }, 500);
                }
                
                // Update time indicator
                updateTimeIndicator();
                
            }, 2000); // Update every 2 seconds
        }

        function playLiveCall(callData) {
            console.log('playLiveCall called with:', callData);
            
            if (!liveScanner.isActive) {
                console.log('Live scanner not active, aborting playback');
                return;
            }
            
            // Stop previous audio
            if (liveScanner.currentAudio) {
                console.log('Stopping previous audio');
                liveScanner.currentAudio.pause();
            }
            
            // Create new audio instance
            const audioUrl = `/api/calls/${callData.id}/audio`;
            console.log('Creating audio instance for URL:', audioUrl);
            liveScanner.currentAudio = new Audio(audioUrl);
            liveScanner.currentAudio.volume = liveScanner.volume;
            
            // Update current call info
            showCurrentCallInfo(callData);
            
            // Add visual feedback
            const waveformContainer = document.getElementById('waveform-container');
            waveformContainer.classList.add('playing');
            
            // Set up audio event listeners
            liveScanner.currentAudio.addEventListener('loadstart', () => {
                console.log('Audio loading started');
            });
            
            liveScanner.currentAudio.addEventListener('canplay', () => {
                console.log('Audio can play');
            });
            
            liveScanner.currentAudio.addEventListener('loadeddata', () => {
                console.log('Audio data loaded');
            });
            
            liveScanner.currentAudio.addEventListener('ended', () => {
                console.log('Audio playback ended');
                waveformContainer.classList.remove('playing');
                hideCurrentCallInfo();
            });
            
            liveScanner.currentAudio.addEventListener('error', (e) => {
                console.error('Live audio playback error:', e);
                console.error('Audio error details:', liveScanner.currentAudio.error);
                waveformContainer.classList.remove('playing');
                hideCurrentCallInfo();
                
                // Show user-friendly error message
                updateMeikoStatus("Audio playback failed", "Check console for details");
            });
            
            liveScanner.currentAudio.addEventListener('play', () => {
                console.log('Audio started playing');
            });
            
            liveScanner.currentAudio.addEventListener('pause', () => {
                console.log('Audio paused');
            });
            
            // Attempt to play the audio
            console.log('Attempting to play audio...');
            const playPromise = liveScanner.currentAudio.play();
            
            if (playPromise !== undefined) {
                playPromise
                    .then(() => {
                        console.log('Audio playback started successfully');
                    })
                    .catch(error => {
                        console.error('Failed to play live audio:', error);
                        
                        // Handle autoplay restriction
                        if (error.name === 'NotAllowedError') {
                            console.log('Autoplay blocked by browser - user interaction required');
                            updateMeikoStatus("Click to enable audio", "Browser autoplay blocked");
                            
                            // Show a play button overlay or notification
                            showAutoplayNotification(callData);
                        } else {
                            console.error('Other audio error:', error);
                            updateMeikoStatus("Audio error", error.message);
                        }
                        
                        waveformContainer.classList.remove('playing');
                        hideCurrentCallInfo();
                    });
            }
            
            liveScanner.lastCallId = callData.id;
            console.log('Updated lastCallId to:', liveScanner.lastCallId);
        }

        function showAutoplayNotification(callData) {
            // Create a temporary notification to enable audio
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--accent-blue);
                color: white;
                padding: 16px;
                border-radius: 4px;
                z-index: 1001;
                cursor: pointer;
                animation: slideIn 0.3s ease-out;
            `;
            notification.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 4px;">ðŸ”Š Enable Audio</div>
                <div style="font-size: 12px;">Click to allow audio playback</div>
            `;
            
            notification.addEventListener('click', () => {
                // User interaction - now we can play audio
                liveScanner.currentAudio.play()
                    .then(() => {
                        console.log('Audio enabled by user interaction');
                        updateMeikoStatus("Audio enabled", "Live scanning active");
                    })
                    .catch(err => {
                        console.error('Still failed to play after user interaction:', err);
                    });
                
                document.body.removeChild(notification);
            });
            
            document.body.appendChild(notification);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    document.body.removeChild(notification);
                }
            }, 10000);
        }

        function showCurrentCallInfo(callData) {
            const currentCallInfo = document.getElementById('current-call-info');
            const title = document.getElementById('call-info-title');
            const meta = document.getElementById('call-info-meta');
            const duration = document.getElementById('call-info-duration');
            
            title.textContent = callData.talkgroup_alias || 'Unknown';
            meta.textContent = `${callData.frequency} â€¢ ${new Date(callData.timestamp).toLocaleTimeString()}`;
            duration.textContent = `${callData.duration}s`;
            
            currentCallInfo.classList.add('active');
        }

        function hideCurrentCallInfo() {
            const currentCallInfo = document.getElementById('current-call-info');
            currentCallInfo.classList.remove('active');
        }

        function addTranscriptionToFeed(callData) {
            if (!callData.transcription) return;
            
            const feed = document.getElementById('transcription-feed');
            
            // Remove empty state if present
            const emptyState = feed.querySelector('.empty-transcription');
            if (emptyState) {
                emptyState.remove();
            }
            
            // Create transcription item
            const item = document.createElement('div');
            item.className = 'transcription-item new';
            
            const timestamp = new Date(callData.timestamp).toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            
            item.innerHTML = `
                <div class="transcription-meta">
                    <span class="transcription-time">${timestamp}</span>
                    <span class="transcription-talkgroup">${callData.talkgroup_alias || 'Unknown'}</span>
                </div>
                <div class="transcription-text">${callData.transcription}</div>
            `;
            
            // Add to top of feed
            feed.insertBefore(item, feed.firstChild);
            
            // Remove 'new' class after animation
            setTimeout(() => {
                item.classList.remove('new');
            }, 2000);
            
            // Keep only last 50 items
            liveScanner.transcriptionItems.unshift(item);
            if (liveScanner.transcriptionItems.length > 50) {
                const oldItem = liveScanner.transcriptionItems.pop();
                if (oldItem.parentNode) {
                    oldItem.parentNode.removeChild(oldItem);
                }
            }
            
            // Auto-scroll to top
            feed.scrollTop = 0;
        }

        function clearTranscriptionFeed() {
            const feed = document.getElementById('transcription-feed');
            feed.innerHTML = `
                <div class="empty-transcription">
                    <i class="fas fa-microphone-slash"></i>
                    <p>Waiting for communications...</p>
                    <small>Live transcriptions will appear here as calls come in</small>
                </div>
            `;
            liveScanner.transcriptionItems = [];
        }

        function testAudioPlayback() {
            console.log('Testing audio playback...');
            updateMeikoStatus("Testing audio", "Fetching recent call for test");
            
            // Get the most recent call for testing
            fetch('/api/calls?limit=1')
                .then(response => response.json())
                .then(data => {
                    if (data.calls && data.calls.length > 0) {
                        const testCall = data.calls[0];
                        console.log('Using call for test:', testCall);
                        
                        updateMeikoStatus("Playing test audio", `Testing with call #${testCall.id}`);
                        
                        // Create test audio
                        const testAudio = new Audio(`/api/calls/${testCall.id}/audio`);
                        testAudio.volume = liveScanner.volume;
                        
                        testAudio.addEventListener('loadeddata', () => {
                            console.log('Test audio loaded successfully');
                        });
                        
                        testAudio.addEventListener('error', (e) => {
                            console.error('Test audio error:', e);
                            updateMeikoStatus("Audio test failed", "Check console for details");
                        });
                        
                        testAudio.addEventListener('ended', () => {
                            console.log('Test audio finished');
                            updateMeikoStatus("Audio test complete", "Audio system working");
                        });
                        
                        // Attempt to play
                        testAudio.play()
                            .then(() => {
                                console.log('Test audio playing successfully');
                                updateMeikoStatus("Audio test playing", "Audio system working");
                                
                                // Update current call info for test
                                showCurrentCallInfo(testCall);
                                
                                // Show waveform
                                const waveformContainer = document.getElementById('waveform-container');
                                waveformContainer.classList.add('playing');
                                
                                // Remove visual feedback when done
                                testAudio.addEventListener('ended', () => {
                                    waveformContainer.classList.remove('playing');
                                    hideCurrentCallInfo();
                                });
                                
                            })
                            .catch(error => {
                                console.error('Test audio failed to play:', error);
                                if (error.name === 'NotAllowedError') {
                                    updateMeikoStatus("Audio blocked", "Browser requires user interaction");
                                    showAutoplayNotification(testCall);
                                } else {
                                    updateMeikoStatus("Audio error", error.message);
                                }
                            });
                    } else {
                        updateMeikoStatus("No calls available", "No audio files to test with");
                        console.log('No calls available for testing');
                    }
                })
                .catch(error => {
                    console.error('Failed to fetch calls for test:', error);
                    updateMeikoStatus("Test failed", "Could not fetch call data");
                });
        }

        // Update the main tab switching to handle live scanner
        function switchTab(tabName) {
            // Update navigation
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');

            currentTab = tabName;

            // Load content for the selected tab
            switch(tabName) {
                case 'timeline':
                    loadTimeline();
                    break;
                case 'live-scanner':
                    if (!liveScanner.waveformCanvas) {
                        initLiveScanner();
                    }
                    // Auto-start scanner when tab is opened for testing
                    if (!liveScanner.isActive) {
                        console.log('Live Scanner tab opened - ready to start');
                        updateMeikoStatus("Live Scanner ready", "Click START SCANNING to begin");
                    }
                    break;
                case 'calls':
                    loadCalls();
                    break;
                case 'analytics':
                    loadAnalytics();
                    break;
                case 'console':
                    loadConsole();
                    break;
            }
        }

        // Enhanced WebSocket message handling for live scanner
        function handleWebSocketMessageForLiveScanner(data) {
            console.log('Live Scanner received WebSocket message:', data);
            
            if (data.type === 'new_call' && liveScanner.isActive) {
                const callData = data.data;
                const liveScannerData = data.live_scanner;
                
                console.log('Live Scanner processing new call:', callData);
                console.log('Live Scanner data:', liveScannerData);
                
                // Add to transcription feed
                addTranscriptionToFeed(callData);
                
                // Update frequency display
                if (liveScannerData && liveScannerData.frequency_info) {
                    const freqInfo = liveScannerData.frequency_info;
                    document.getElementById('active-frequency').textContent = 
                        `${freqInfo.frequency} â€¢ ${freqInfo.description}`;
                    console.log('Updated frequency display:', freqInfo);
                }
                
                // Use real waveform data if available
                if (liveScannerData && liveScannerData.waveform_data) {
                    console.log('Drawing real waveform data:', liveScannerData.waveform_data.length, 'points');
                    drawRealWaveform(liveScannerData.waveform_data);
                }
                
                // Auto-play if this is a new call and auto-play is enabled
                if (callData.id !== liveScanner.lastCallId) {
                    console.log('Attempting to play new call:', callData.id, 'Previous call:', liveScanner.lastCallId);
                    
                    if (liveScannerData && liveScannerData.should_auto_play) {
                        console.log('Auto-play enabled, starting playback in 500ms');
                        // Small delay to ensure audio file is ready
                        setTimeout(() => {
                            playLiveCall(callData);
                        }, 500);
                    } else {
                        console.log('Auto-play disabled or no live scanner data');
                    }
                } else {
                    console.log('Same call ID, skipping auto-play');
                }
            } else if (data.type === 'new_call' && !liveScanner.isActive) {
                console.log('Live Scanner not active, ignoring new call');
            }
            
            // Handle live scanner specific events
            if (data.type === 'live_scanner_event') {
                console.log('Received live scanner event:', data.event, data.data);
                switch(data.event) {
                    case 'frequency_change':
                        updateFrequencyDisplay(data.data);
                        break;
                    case 'signal_strength':
                        updateSignalStrength(data.data);
                        break;
                    case 'scanner_status':
                        updateScannerStatus(data.data);
                        break;
                }
            }
        }

        function updateFrequencyDisplay(freqData) {
            document.getElementById('active-frequency').textContent = 
                `${freqData.frequency} â€¢ ${freqData.description || 'Monitoring'}`;
        }

        function updateSignalStrength(signalData) {
            // Could be used to update a signal strength indicator
            console.log('Signal strength:', signalData);
        }

        function updateScannerStatus(statusData) {
            // Update scanner status based on backend events
            const status = document.getElementById('scanner-status');
            if (statusData.active) {
                status.className = 'scanner-indicator live';
                status.querySelector('span').textContent = 'LIVE';
            } else {
                status.className = 'scanner-indicator standby';
                status.querySelector('span').textContent = 'STANDBY';
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('call-modal');
            if (event.target === modal) {
                closeCallModal();
            }
        }
    </script>
</body>
</html> 